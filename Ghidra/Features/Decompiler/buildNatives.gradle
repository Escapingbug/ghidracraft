/* ###
 * IP: GHIDRA
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Native build files are already applied in development mode (indicated by presence of the
// Generic project).  Only need to apply them if we are in a distribution.
if (findProject(':Generic') == null) {
	apply from: "../../../GPL/utils.gradle"
	apply from: "../../../GPL/nativePlatforms.gradle"
	apply from: "../../../GPL/nativeBuildProperties.gradle"
}

/**
 * Define the "native build model" for building the decompiler executables.
 */

def getTargetArch() {

	def arch = System.getenv("TARGET_ARCH")

	if (arch == null) {
		arch = System.getProperty("os.arch")
	}

	if (arch == "aarch64") {
		return arch
	} else if (arch == "amd64" || arch == "x86_64") {
		return "x86_64"
	} else {
		throw new Exception("unsupported architecture ${arch}")
	}
}

task win64BuildDecompilerRust(type: Exec) {
	if (isCurrentWindows()) {
		exec {
			workingDir "./src/decompile"

			def arch = null

			try {
				arch = getTargetArch()
			} catch (Exception e) {
				throw new TaskExecutionException(it, e)
			}

			def target = "${arch}-pc-windows-msvc"
			commandLine 'cargo', 'build', '--release', '--target', target, '-Z', 'unstable-options', '--out-dir', '../../build/os/win_x86_64'
		}
	}
}

task linux64BuildDecompilerRust(type: Exec) {
	if (isCurrentLinux()) {
		exec {
			workingDir "./src/decompile"

			def out_path = null
			def arch = null

			try {
				arch = getTargetArch()
			} catch (Exception e) {
				throw new TaskExecutionException(it, e)
			}

			if (arch == "aarch64") {
				out_path = "../../build/os/linux_arm_64"
			} else {
				out_path = "../../build/os/linux_x86_64"
			}

			def target = "${arch}-unknown-linux-gnu"
			commandLine 'cargo', 'build', '--release', '--target', target, '-Z', 'unstable-options', '--out-dir', out_path
		}
	}
}

task osx64BuildDecompilerRust(type: Exec) {
	if (isCurrentMac()) {
		exec {
			workingDir "./src/decompile"
			def out_path = null
			def arch = null

			try {
				arch = getTargetArch()
			} catch (Exception e) {
				throw new TaskExecutionException(it, e)
			}

			if (arch == "aarch64") {
				out_path = "../../build/os/mac_arm_64"
			} else {
				out_path = "../../build/os/mac_x86_64"
			}

			def target = "${arch}-apple-darwin"
			commandLine 'cargo', 'build', '--release', '--target', target, '-Z', 'unstable-options', '--out-dir', out_path
		}
	}
}
model {

	// Define the source files that are compiled and linked to become the decompiler.
	// The decompiler source is a bit weird in that all the cpp and headers all live in
	// the same directory with other files that are not used by the decompiler.
	// That is why we have to list every cpp file that makes up the decomplier.
	components {
		sleigh(NativeExecutableSpec) {
			targetPlatform "win_x86_64"
			targetPlatform "linux_x86_64"
			targetPlatform "linux_arm_64"
			targetPlatform "mac_x86_64"
			targetPlatform "mac_arm_64"
			sources {
				cpp {
					// NOTE: The bison/flex generated files are assumed to be up-to-date.
					//       The task `generateParsers` should be executed if needed.
					// builtBy lexSleigh
					source {
						srcDir "src/decompile/cpp"

						include "space.cc"
						include "float.cc"
						include "address.cc"
						include "pcoderaw.cc"
						include "translate.cc"
						include "opcodes.cc"
						include "globalcontext.cc"
						include "sleigh.cc"
						include "pcodecompile.cc"
						include "sleighbase.cc"
						include "slghsymbol.cc"
						include "slghpatexpress.cc"
						include "slghpattern.cc"
						include "semantics.cc"
						include "context.cc"
						include "filemanage.cc"
						include "slgh_compile.cc"

						// generated source files

						include "xml.cc"
						include "pcodeparse.cc"
						include "slghparse.cc"
						include "slghscan.cc"
					}
					exportedHeaders {
						srcDir "src/decompile/cpp"
					}
				} // end cpp
			} // end sources (sleigh)
		} // end sleigh

	}  // end components

	binaries {
		all{ b ->
			if (b.toolChain in Gcc) {
				b.cppCompiler.args "-std=c++14"
				b.cppCompiler.args "-Wall"
				b.cppCompiler.args "-O2"			// for DEBUG, comment this line out
				// b.cppCompiler.args "-g"			// for DEBUG, uncomment	this line
				b.cppCompiler.args "-Wno-sign-compare"
				if (b.targetPlatform.operatingSystem.linux) {
//					b.linker.args "-static"
					b.cppCompiler.define "LINUX"
					b.cppCompiler.define "_LINUX"
				}
			}
			else if (b.toolChain in VisualCpp) {
				b.cppCompiler.args "/EHsc"
				b.cppCompiler.define "_SECURE_SCL=0"
				b.cppCompiler.define "_HAS_ITERATOR_DEBUGGING=0"
				// b.cppCompiler.args "/Zi"		// for DEBUG, uncomment this line
				// b.cppCompiler.args "/FS"		// for DEBUG, uncomment this line
				// b.linker.args "/DEBUG"		// for DEBUG, uncomment this line
				if (b.targetPlatform.operatingSystem.windows) {
					b.cppCompiler.define "WINDOWS"
					b.cppCompiler.define "_WINDOWS"
					b.cppCompiler.define "WIN32"
					b.cppCompiler.define "_WIN32"
					if (b.targetPlatform.name == "win_x86_64") {
						b.cppCompiler.define "WIN64"
						b.cppCompiler.define "_WIN64"
					}
				}
			}
			else if (b.toolChain in Clang) {
				b.cppCompiler.args "-std=c++14"
				b.cppCompiler.args "-Wall"
				b.cppCompiler.args "-O2"			// for DEBUG, comment this line out
				// b.cppCompiler.args "-g"			// for DEBUG, uncomment	this line
				b.cppCompiler.args "-Wno-sign-compare"
				b.cppCompiler.args "-w"
				if (b.targetPlatform.operatingSystem.linux) {
//					b.linker.args "-static"
				}
			}
		}
	}
} // end model
